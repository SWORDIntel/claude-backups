#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════
# CLAUDE UNIFIED WRAPPER v3.0 - ADVANCED ORCHESTRATION & INTELLIGENCE
# 
# Next-generation wrapper with:
# • Intelligent task analysis and routing
# • Multi-mode execution (Solo, Team, Hybrid)
# • Performance tracking and optimization
# • Agent capability matching
# • Interactive workflow designer
# • Task templates and patterns
# 
# Version: 3.0 - Advanced Intelligence Architecture
# ═══════════════════════════════════════════════════════════════════════════

set -euo pipefail

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# CONFIGURATION & INITIALIZATION
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_VERSION="3.0-advanced"

# Find project root intelligently
find_project_root() {
    local current_dir="$SCRIPT_DIR"
    local max_depth=5
    local depth=0
    
    while [ $depth -lt $max_depth ]; do
        if [ -d "$current_dir/.claude-home" ] || [ -d "$current_dir/agents" ]; then
            echo "$current_dir"
            return 0
        fi
        [ "$current_dir" = "/" ] && break
        current_dir="$(cd "$current_dir/.." && pwd)"
        depth=$((depth + 1))
    done
    
    # Check common locations
    for dir in "$HOME/Documents/Claude" "$HOME/claude-backups" "$HOME/.local/share/claude"; do
        [ -d "$dir/agents" ] && echo "$dir" && return 0
    done
    
    echo "$HOME/.local/share/claude"
}

PROJECT_ROOT="$(find_project_root)"
AGENTS_DIR="${CLAUDE_AGENTS_DIR:-$PROJECT_ROOT/agents}"
CONFIG_DIR="$HOME/.config/claude"
CACHE_DIR="$HOME/.cache/claude"
HISTORY_FILE="$CACHE_DIR/task_history.json"
METRICS_FILE="$CACHE_DIR/metrics.json"

# Orchestration paths
ORCHESTRATOR_PATH="$PROJECT_ROOT/agents/src/python/tandem_orchestrator.py"
PRODUCTION_ORCHESTRATOR="$PROJECT_ROOT/agents/src/python/production_orchestrator.py"

# Feature flags
PERMISSION_BYPASS=${CLAUDE_PERMISSION_BYPASS:-true}
ORCHESTRATION_ENABLED=${CLAUDE_ORCHESTRATION:-true}
INTERACTIVE_MODE=${CLAUDE_INTERACTIVE:-true}
DEBUG_MODE=${CLAUDE_DEBUG:-false}
METRICS_ENABLED=${CLAUDE_METRICS:-true}
CACHE_SUGGESTIONS=${CLAUDE_CACHE:-true}

# Colors & UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly MAGENTA='\033[0;35m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly NC='\033[0m'

# UI elements
readonly CHECK="✓"
readonly CROSS="✗"
readonly ARROW="→"
readonly DOT="•"
readonly STAR="★"

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# INITIALIZATION
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

initialize_environment() {
    mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
    
    # Initialize history file
    if [ ! -f "$HISTORY_FILE" ]; then
        echo '{"tasks": [], "preferences": {}}' > "$HISTORY_FILE"
    fi
    
    # Initialize metrics
    if [ ! -f "$METRICS_FILE" ]; then
        echo '{"executions": 0, "orchestrated": 0, "total_time": 0}' > "$METRICS_FILE"
    fi
    
    # Set up Python path
    export PYTHONPATH="$PROJECT_ROOT/agents/src/python${PYTHONPATH:+:$PYTHONPATH}"
    export CLAUDE_PROJECT_ROOT="$PROJECT_ROOT"
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# LOGGING & DEBUG
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

log_debug() {
    [ "$DEBUG_MODE" = "true" ] && echo -e "${DIM}[DEBUG] $1${NC}" >&2
}

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_orchestration() {
    echo -e "${CYAN}[ORCHESTRATE]${NC} $1" >&2
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# TASK ANALYSIS ENGINE
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

analyze_task() {
    local task="$1"
    
    python3 -c "
import re
import json
import sys

task = '''$task'''

# Task complexity scoring
complexity_score = 0
suggested_agents = []
execution_mode = 'solo'
estimated_time = 5

# Pattern definitions
patterns = {
    'development': {
        'keywords': ['create', 'build', 'develop', 'implement', 'code'],
        'agents': ['engineer', 'architect'],
        'weight': 10
    },
    'testing': {
        'keywords': ['test', 'verify', 'validate', 'check', 'qa'],
        'agents': ['testbed', 'qa_specialist'],
        'weight': 8
    },
    'security': {
        'keywords': ['security', 'audit', 'vulnerability', 'secure', 'protect'],
        'agents': ['security', 'securitychaosagent'],
        'weight': 15
    },
    'documentation': {
        'keywords': ['document', 'docs', 'readme', 'explain', 'describe'],
        'agents': ['docgen', 'technical_writer'],
        'weight': 5
    },
    'deployment': {
        'keywords': ['deploy', 'release', 'publish', 'ship', 'launch'],
        'agents': ['deployer', 'devops'],
        'weight': 12
    },
    'analysis': {
        'keywords': ['analyze', 'review', 'assess', 'evaluate', 'inspect'],
        'agents': ['analyst', 'reviewer'],
        'weight': 7
    },
    'optimization': {
        'keywords': ['optimize', 'improve', 'enhance', 'refactor', 'performance'],
        'agents': ['optimizer', 'performance_engineer'],
        'weight': 10
    },
    'design': {
        'keywords': ['design', 'architect', 'plan', 'structure', 'blueprint'],
        'agents': ['architect', 'designer'],
        'weight': 12
    }
}

# Analyze task
task_lower = task.lower()
matched_categories = []

for category, info in patterns.items():
    for keyword in info['keywords']:
        if keyword in task_lower:
            complexity_score += info['weight']
            suggested_agents.extend(info['agents'])
            matched_categories.append(category)
            break

# Determine execution mode based on complexity
if complexity_score >= 30:
    execution_mode = 'orchestrated_team'
    estimated_time = 30
elif complexity_score >= 15:
    execution_mode = 'hybrid'
    estimated_time = 15
else:
    execution_mode = 'solo'
    estimated_time = 5

# Multi-step detection
if any(word in task_lower for word in ['and then', 'followed by', 'after that', 'multi', 'pipeline']):
    execution_mode = 'orchestrated_pipeline'
    complexity_score += 20
    estimated_time = 45

# Remove duplicates from agents
suggested_agents = list(set(suggested_agents))

# Output analysis
result = {
    'complexity_score': complexity_score,
    'execution_mode': execution_mode,
    'suggested_agents': suggested_agents[:5],  # Top 5 agents
    'matched_categories': matched_categories,
    'estimated_time': estimated_time,
    'requires_orchestration': complexity_score >= 15
}

print(json.dumps(result))
" 2>/dev/null || echo '{"complexity_score": 0, "execution_mode": "solo", "suggested_agents": [], "requires_orchestration": false}'
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# AGENT DISCOVERY & MANAGEMENT
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

discover_agents() {
    local agent_list=()
    
    if [ -d "$AGENTS_DIR" ]; then
        while IFS= read -r agent_file; do
            local agent_name=$(basename "$agent_file" | sed 's/\.[mM][dD]$//')
            local agent_role="Unknown"
            
            # Try to extract role from agent file
            if grep -q "^role:" "$agent_file" 2>/dev/null; then
                agent_role=$(grep "^role:" "$agent_file" | head -1 | cut -d: -f2 | xargs)
            elif grep -q "^# " "$agent_file" 2>/dev/null; then
                agent_role=$(grep "^# " "$agent_file" | head -1 | sed 's/^# //')
            fi
            
            agent_list+=("${agent_name}:${agent_role}")
        done < <(find "$AGENTS_DIR" -maxdepth 1 -name "*.md" -o -name "*.MD" 2>/dev/null)
    fi
    
    printf '%s\n' "${agent_list[@]}"
}

match_agents_to_task() {
    local task="$1"
    local analysis="$2"
    
    # Get suggested agents from analysis
    local suggested=$(echo "$analysis" | python3 -c "
import sys, json
data = json.loads(sys.stdin.read())
for agent in data.get('suggested_agents', []):
    print(agent)
")
    
    # Get available agents
    local available_agents=$(discover_agents)
    
    # Match and display
    echo -e "${CYAN}${BOLD}Available Agents for This Task:${NC}"
    
    local matched=0
    while IFS=: read -r name role; do
        for suggested in $suggested; do
            if [[ "$name" == *"$suggested"* ]] || [[ "$suggested" == *"$name"* ]]; then
                echo -e "  ${GREEN}${CHECK}${NC} ${BOLD}$name${NC} - $role"
                matched=$((matched + 1))
            fi
        done
    done <<< "$available_agents"
    
    if [ $matched -eq 0 ]; then
        # Show general agents
        echo "$available_agents" | head -5 | while IFS=: read -r name role; do
            echo -e "  ${DOT} ${name} - ${role}"
        done
    fi
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# TASK TEMPLATES & WORKFLOWS
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

show_task_templates() {
    cat << EOF
${CYAN}${BOLD}═══════════════════════════════════════════════════════════${NC}
${CYAN}${BOLD}          Task Templates & Workflows${NC}
${CYAN}${BOLD}═══════════════════════════════════════════════════════════${NC}

${GREEN}${BOLD}1. Full Feature Development${NC}
   ${DIM}Template: "Create [feature] with tests and documentation"${NC}
   ${DOT} Agents: architect, engineer, testbed, docgen
   ${DOT} Mode: Orchestrated Pipeline
   ${DOT} Time: ~45 minutes

${BLUE}${BOLD}2. Security Audit${NC}
   ${DIM}Template: "Perform security audit on [component]"${NC}
   ${DOT} Agents: security, securitychaosagent, reviewer
   ${DOT} Mode: Team Consensus
   ${DOT} Time: ~30 minutes

${YELLOW}${BOLD}3. Bug Fix & Verify${NC}
   ${DIM}Template: "Fix [issue] and verify with tests"${NC}
   ${DOT} Agents: debugger, engineer, testbed
   ${DOT} Mode: Hybrid
   ${DOT} Time: ~20 minutes

${MAGENTA}${BOLD}4. Documentation Sprint${NC}
   ${DIM}Template: "Document [system] comprehensively"${NC}
   ${DOT} Agents: docgen, technical_writer, reviewer
   ${DOT} Mode: Parallel Execution
   ${DOT} Time: ~25 minutes

${CYAN}${BOLD}5. Performance Optimization${NC}
   ${DIM}Template: "Optimize [component] for performance"${NC}
   ${DOT} Agents: performance_engineer, optimizer, testbed
   ${DOT} Mode: Iterative Refinement
   ${DOT} Time: ~35 minutes

${GREEN}${BOLD}6. Code Review & Refactor${NC}
   ${DIM}Template: "Review and refactor [codebase]"${NC}
   ${DOT} Agents: reviewer, architect, engineer
   ${DOT} Mode: Consensus Building
   ${DOT} Time: ~30 minutes

EOF
}

apply_template() {
    local template_num="$1"
    local user_input="$2"
    
    case "$template_num" in
        1)
            echo "Create $user_input with comprehensive tests, documentation, and deployment configuration"
            ;;
        2)
            echo "Perform comprehensive security audit on $user_input including vulnerability scanning, penetration testing, and compliance check"
            ;;
        3)
            echo "Fix the bug in $user_input, create regression tests, and verify the solution works correctly"
            ;;
        4)
            echo "Create comprehensive documentation for $user_input including API docs, user guide, and technical specifications"
            ;;
        5)
            echo "Optimize $user_input for maximum performance including profiling, bottleneck analysis, and implementation of improvements"
            ;;
        6)
            echo "Review $user_input for code quality, refactor for maintainability, and ensure best practices"
            ;;
        *)
            echo "$user_input"
            ;;
    esac
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# EXECUTION MODES
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

execute_solo_mode() {
    local claude_bin="$1"
    shift
    local args=("$@")
    
    log_info "Executing in SOLO mode (single agent)"
    
    # Add permission bypass if enabled
    if [ "$PERMISSION_BYPASS" = "true" ]; then
        args=("--dangerously-skip-permissions" "${args[@]}")
    fi
    
    # Track metrics
    local start_time=$(date +%s)
    
    # Execute
    "$claude_bin" "${args[@]}"
    local exit_code=$?
    
    # Update metrics
    if [ "$METRICS_ENABLED" = "true" ]; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        update_metrics "solo" $duration
    fi
    
    return $exit_code
}

execute_orchestrated_mode() {
    local mode="$1"
    shift
    local args=("$@")
    
    log_orchestration "Launching $mode orchestration"
    
    # Determine which orchestrator to use
    local orchestrator="$ORCHESTRATOR_PATH"
    if [ "$mode" = "production" ] && [ -f "$PRODUCTION_ORCHESTRATOR" ]; then
        orchestrator="$PRODUCTION_ORCHESTRATOR"
    fi
    
    if [ ! -f "$orchestrator" ]; then
        log_error "Orchestrator not found at: $orchestrator"
        return 1
    fi
    
    # Set environment for orchestrator
    export CLAUDE_EXECUTION_MODE="$mode"
    export CLAUDE_PERMISSION_BYPASS="$PERMISSION_BYPASS"
    
    # Track metrics
    local start_time=$(date +%s)
    
    # Launch orchestrator
    cd "$(dirname "$orchestrator")"
    python3 "$(basename "$orchestrator")" --task "${args[@]}"
    local exit_code=$?
    
    # Update metrics
    if [ "$METRICS_ENABLED" = "true" ]; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        update_metrics "orchestrated" $duration
    fi
    
    return $exit_code
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# INTERACTIVE UI
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

show_task_analysis_ui() {
    local task="$1"
    local analysis="$2"
    
    # Parse analysis
    local complexity=$(echo "$analysis" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['complexity_score'])")
    local mode=$(echo "$analysis" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['execution_mode'])")
    local time=$(echo "$analysis" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['estimated_time'])")
    local categories=$(echo "$analysis" | python3 -c "import sys,json; d=json.loads(sys.stdin.read()); print(', '.join(d['matched_categories']))")
    
    clear
    echo -e "${CYAN}${BOLD}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}${BOLD}║             CLAUDE TASK ANALYSIS & ROUTING                  ║${NC}"
    echo -e "${CYAN}${BOLD}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${BOLD}Task:${NC} ${task:0:60}..."
    echo
    echo -e "${BOLD}Analysis Results:${NC}"
    echo -e "  ${DOT} Complexity Score: $(show_complexity_bar $complexity)"
    echo -e "  ${DOT} Categories: ${CYAN}$categories${NC}"
    echo -e "  ${DOT} Estimated Time: ${YELLOW}~$time minutes${NC}"
    echo -e "  ${DOT} Recommended Mode: ${GREEN}$mode${NC}"
    echo
    
    # Show agent matches
    match_agents_to_task "$task" "$analysis"
    echo
    
    # Show execution options
    echo -e "${BOLD}Execution Options:${NC}"
    echo -e "  ${CYAN}[1]${NC} ${STAR} Orchestrated Team ${DIM}(Recommended)${NC}"
    echo -e "       Multiple agents working in parallel/sequence"
    echo
    echo -e "  ${BLUE}[2]${NC} Solo Execution ${DIM}(Traditional)${NC}"
    echo -e "       Single Claude instance"
    echo
    echo -e "  ${YELLOW}[3]${NC} Hybrid Mode"
    echo -e "       Claude with selective agent assistance"
    echo
    echo -e "  ${MAGENTA}[4]${NC} Custom Configuration"
    echo -e "       Choose specific agents and mode"
    echo
    echo -e "  ${GREEN}[5]${NC} Show Task Templates"
    echo -e "       Pre-configured workflows"
    echo
    echo -e "  ${DIM}[6]${NC} ${DIM}Cancel${NC}"
    echo
}

show_complexity_bar() {
    local score=$1
    local bar=""
    local level=""
    
    if [ $score -lt 10 ]; then
        bar="${GREEN}▰▱▱▱▱${NC}"
        level="Simple"
    elif [ $score -lt 20 ]; then
        bar="${YELLOW}▰▰▱▱▱${NC}"
        level="Moderate"
    elif [ $score -lt 30 ]; then
        bar="${YELLOW}▰▰▰▱▱${NC}"
        level="Complex"
    elif [ $score -lt 40 ]; then
        bar="${RED}▰▰▰▰▱${NC}"
        level="Very Complex"
    else
        bar="${RED}▰▰▰▰▰${NC}"
        level="Extreme"
    fi
    
    echo "$bar $level ($score)"
}

interactive_mode_selection() {
    local task="$1"
    local analysis="$2"
    
    show_task_analysis_ui "$task" "$analysis"
    
    echo -n "Select option [1-6]: "
    read -n 1 choice
    echo
    echo
    
    case "$choice" in
        1)
            return 1  # Orchestrated
            ;;
        2)
            return 2  # Solo
            ;;
        3)
            return 3  # Hybrid
            ;;
        4)
            custom_configuration "$task"
            return $?
            ;;
        5)
            show_task_templates
            echo -n "Select template [1-6] or press Enter to continue: "
            read template_choice
            if [ -n "$template_choice" ]; then
                echo -n "Enter specifics for template: "
                read template_input
                local new_task=$(apply_template "$template_choice" "$template_input")
                main "/task" "$new_task"
                exit $?
            fi
            return 0
            ;;
        6|*)
            return 255  # Cancel
            ;;
    esac
}

custom_configuration() {
    local task="$1"
    
    echo -e "${CYAN}${BOLD}Custom Configuration${NC}"
    echo
    
    # Show available agents
    echo "Available agents:"
    local agents=($(discover_agents | cut -d: -f1))
    local i=1
    for agent in "${agents[@]}"; do
        echo "  [$i] $agent"
        i=$((i + 1))
    done
    echo
    
    echo -n "Select agents (comma-separated numbers): "
    read agent_selection
    
    echo
    echo "Execution modes:"
    echo "  [1] Sequential (one after another)"
    echo "  [2] Parallel (all at once)"
    echo "  [3] Consensus (vote on solution)"
    echo "  [4] Pipeline (output feeds next)"
    echo
    echo -n "Select mode: "
    read -n 1 mode_selection
    echo
    
    # Build custom command
    local selected_agents=""
    IFS=',' read -ra selections <<< "$agent_selection"
    for sel in "${selections[@]}"; do
        sel=$((sel - 1))
        if [ $sel -ge 0 ] && [ $sel -lt ${#agents[@]} ]; then
            selected_agents="$selected_agents,${agents[$sel]}"
        fi
    done
    selected_agents=${selected_agents:1}  # Remove leading comma
    
    log_info "Custom configuration: agents=$selected_agents, mode=$mode_selection"
    
    # Execute with custom config
    export CLAUDE_CUSTOM_AGENTS="$selected_agents"
    export CLAUDE_CUSTOM_MODE="$mode_selection"
    
    return 1  # Proceed with orchestration
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# METRICS & HISTORY
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

update_metrics() {
    local mode="$1"
    local duration="$2"
    
    python3 -c "
import json
import os

metrics_file = '$METRICS_FILE'

# Load existing metrics
if os.path.exists(metrics_file):
    with open(metrics_file, 'r') as f:
        metrics = json.load(f)
else:
    metrics = {'executions': 0, 'orchestrated': 0, 'total_time': 0}

# Update metrics
metrics['executions'] += 1
if '$mode' == 'orchestrated':
    metrics['orchestrated'] += 1
metrics['total_time'] += $duration

# Save metrics
with open(metrics_file, 'w') as f:
    json.dump(metrics, f, indent=2)
" 2>/dev/null || true
}

save_task_to_history() {
    local task="$1"
    local mode="$2"
    
    python3 -c "
import json
import os
from datetime import datetime

history_file = '$HISTORY_FILE'

# Load existing history
if os.path.exists(history_file):
    with open(history_file, 'r') as f:
        history = json.load(f)
else:
    history = {'tasks': [], 'preferences': {}}

# Add new task
history['tasks'].append({
    'task': '''$task''',
    'mode': '$mode',
    'timestamp': datetime.now().isoformat()
})

# Keep only last 100 tasks
history['tasks'] = history['tasks'][-100:]

# Save history
with open(history_file, 'w') as f:
    json.dump(history, f, indent=2)
" 2>/dev/null || true
}

show_metrics() {
    if [ ! -f "$METRICS_FILE" ]; then
        echo "No metrics available yet"
        return
    fi
    
    python3 -c "
import json

with open('$METRICS_FILE', 'r') as f:
    metrics = json.load(f)

print('${CYAN}${BOLD}═══════════════════════════════════════════════════════════${NC}')
print('${CYAN}${BOLD}                   Execution Metrics${NC}')
print('${CYAN}${BOLD}═══════════════════════════════════════════════════════════${NC}')
print()
print(f'Total Executions: {metrics[\"executions\"]}')
print(f'Orchestrated Runs: {metrics[\"orchestrated\"]}')
if metrics['executions'] > 0:
    orch_pct = (metrics['orchestrated'] / metrics['executions']) * 100
    print(f'Orchestration Rate: {orch_pct:.1f}%')
    avg_time = metrics['total_time'] / metrics['executions']
    print(f'Average Execution Time: {avg_time:.0f} seconds')
print()
"
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# CLAUDE BINARY DETECTION
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

find_claude_binary() {
    local claude_bin=""
    
    # Check for original binary
    for loc in \
        "$HOME/.local/npm-global/bin/claude.original" \
        "$HOME/.local/bin/claude.original" \
        "/usr/local/bin/claude.original" \
        "$(npm root -g 2>/dev/null)/@anthropic-ai/claude-code/bin/claude"
    do
        if [ -f "$loc" ] && [ -x "$loc" ] && [ "$loc" != "$0" ]; then
            claude_bin="$loc"
            log_debug "Found Claude binary at: $loc"
            break
        fi
    done
    
    # Fallback to system claude
    if [ -z "$claude_bin" ]; then
        local system_claude=$(which claude 2>/dev/null || which claude-code 2>/dev/null)
        if [ -n "$system_claude" ] && [ "$system_claude" != "$0" ]; then
            claude_bin="$system_claude"
            log_debug "Using system Claude at: $system_claude"
        fi
    fi
    
    echo "$claude_bin"
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# MAIN EXECUTION
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

main() {
    # Initialize environment
    initialize_environment
    
    # Handle special commands
    case "${1:-}" in
        --unified-help|--help|-h)
            show_help
            exit 0
            ;;
        --unified-status|--status)
            show_status
            exit 0
            ;;
        --metrics)
            show_metrics
            exit 0
            ;;
        --templates)
            show_task_templates
            exit 0
            ;;
        --version|-v)
            echo "Claude Unified Wrapper v$SCRIPT_VERSION"
            exit 0
            ;;
    esac
    
    # Find Claude binary
    local claude_bin=$(find_claude_binary)
    if [ -z "$claude_bin" ]; then
        log_error "Claude Code not found!"
        echo "Install with: npm install -g @anthropic-ai/claude-code"
        exit 1
    fi
    
    # Parse arguments
    local task_mode=false
    local task_text=""
    local args=()
    
    for arg in "$@"; do
        case "$arg" in
            /task|task)
                task_mode=true
                ;;
            --no-orchestration)
                ORCHESTRATION_ENABLED=false
                ;;
            --no-interactive)
                INTERACTIVE_MODE=false
                ;;
            *)
                args+=("$arg")
                if [ "$task_mode" = true ]; then
                    task_text="$task_text $arg"
                fi
                ;;
        esac
    done
    
    # Handle task mode
    if [ "$task_mode" = true ] && [ "$ORCHESTRATION_ENABLED" = "true" ]; then
        log_debug "Task detected: $task_text"
        
        # Analyze task
        local analysis=$(analyze_task "$task_text")
        log_debug "Analysis: $analysis"
        
        # Check if orchestration is recommended
        local requires_orch=$(echo "$analysis" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['requires_orchestration'])")
        
        if [ "$requires_orch" = "True" ]; then
            if [ "$INTERACTIVE_MODE" = "true" ]; then
                # Interactive mode selection
                interactive_mode_selection "$task_text" "$analysis"
                local selection=$?
                
                case $selection in
                    1)  # Orchestrated
                        execute_orchestrated_mode "team" "/task" "$task_text"
                        exit $?
                        ;;
                    2)  # Solo
                        execute_solo_mode "$claude_bin" "/task" "$task_text"
                        exit $?
                        ;;
                    3)  # Hybrid
                        execute_orchestrated_mode "hybrid" "/task" "$task_text"
                        exit $?
                        ;;
                    255)  # Cancel
                        echo "Cancelled"
                        exit 0
                        ;;
                esac
            else
                # Auto-orchestrate
                log_orchestration "Auto-orchestrating complex task"
                execute_orchestrated_mode "intelligent" "/task" "$task_text"
                exit $?
            fi
        fi
    fi
    
    # Default: execute in solo mode
    execute_solo_mode "$claude_bin" "$@"
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# HELP & STATUS
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

show_help() {
    cat << EOF
${CYAN}${BOLD}Claude Unified Wrapper v$SCRIPT_VERSION${NC}
Advanced Orchestration & Intelligence System

${BOLD}USAGE:${NC}
  claude [options] [command] [arguments]

${BOLD}FEATURES:${NC}
  ${DOT} Intelligent task analysis and routing
  ${DOT} Multi-mode execution (Solo, Team, Hybrid)
  ${DOT} Performance tracking and optimization
  ${DOT} Agent capability matching
  ${DOT} Task templates and workflows
  ${DOT} Interactive mode selection

${BOLD}OPTIONS:${NC}
  --no-orchestration    Disable orchestration suggestions
  --no-interactive      Disable interactive mode
  --metrics            Show execution metrics
  --templates          Show task templates
  --status             Show system status
  --help               Show this help

${BOLD}ENVIRONMENT:${NC}
  CLAUDE_ORCHESTRATION=false    Disable orchestration
  CLAUDE_INTERACTIVE=false      Disable interactive mode
  CLAUDE_PERMISSION_BYPASS=false Disable permission bypass
  CLAUDE_DEBUG=true             Enable debug output
  CLAUDE_METRICS=false          Disable metrics tracking

${BOLD}EXAMPLES:${NC}
  ${DIM}# Complex task with auto-orchestration${NC}
  claude /task "create a web app with tests and deploy it"
  
  ${DIM}# Simple task in solo mode${NC}
  claude /task "fix this typo"
  
  ${DIM}# Force solo mode${NC}
  claude --no-orchestration /task "complex task"
  
  ${DIM}# Use task template${NC}
  claude --templates

${BOLD}PROJECT ROOT:${NC} $PROJECT_ROOT
${BOLD}AGENTS DIR:${NC} $AGENTS_DIR
EOF
}

show_status() {
    echo -e "${CYAN}${BOLD}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}${BOLD}              Claude Unified System Status${NC}"
    echo -e "${CYAN}${BOLD}═══════════════════════════════════════════════════════════${NC}"
    echo
    
    # Claude binary
    local claude_bin=$(find_claude_binary)
    if [ -n "$claude_bin" ]; then
        echo -e "Claude Binary: ${GREEN}${CHECK} Found${NC}"
        echo -e "  Location: $claude_bin"
    else
        echo -e "Claude Binary: ${RED}${CROSS} Not found${NC}"
    fi
    
    # Project structure
    echo
    echo -e "${BOLD}Project Structure:${NC}"
    echo -e "  Project Root: $PROJECT_ROOT"
    if [ -d "$PROJECT_ROOT/agents" ]; then
        local agent_count=$(find "$PROJECT_ROOT/agents" -name "*.md" 2>/dev/null | wc -l)
        echo -e "  Agents: ${GREEN}${CHECK}${NC} $agent_count agents found"
    else
        echo -e "  Agents: ${RED}${CROSS}${NC} Not found"
    fi
    
    # Orchestration
    echo
    echo -e "${BOLD}Orchestration:${NC}"
    if [ -f "$ORCHESTRATOR_PATH" ]; then
        echo -e "  Tandem Orchestrator: ${GREEN}${CHECK} Available${NC}"
    else
        echo -e "  Tandem Orchestrator: ${RED}${CROSS} Not found${NC}"
    fi
    
    if [ -f "$PRODUCTION_ORCHESTRATOR" ]; then
        echo -e "  Production Orchestrator: ${GREEN}${CHECK} Available${NC}"
    else
        echo -e "  Production Orchestrator: ${YELLOW}${DOT} Not found${NC}"
    fi
    
    # Features
    echo
    echo -e "${BOLD}Features:${NC}"
    [ "$PERMISSION_BYPASS" = "true" ] && echo -e "  Permission Bypass: ${GREEN}Enabled${NC}" || echo -e "  Permission Bypass: ${YELLOW}Disabled${NC}"
    [ "$ORCHESTRATION_ENABLED" = "true" ] && echo -e "  Orchestration: ${GREEN}Enabled${NC}" || echo -e "  Orchestration: ${YELLOW}Disabled${NC}"
    [ "$INTERACTIVE_MODE" = "true" ] && echo -e "  Interactive Mode: ${GREEN}Enabled${NC}" || echo -e "  Interactive Mode: ${YELLOW}Disabled${NC}"
    [ "$METRICS_ENABLED" = "true" ] && echo -e "  Metrics Tracking: ${GREEN}Enabled${NC}" || echo -e "  Metrics Tracking: ${YELLOW}Disabled${NC}"
    
    # Show recent metrics
    if [ -f "$METRICS_FILE" ] && [ "$METRICS_ENABLED" = "true" ]; then
        echo
        show_metrics
    fi
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# ENTRY POINT
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Execute main function
main "$@"
