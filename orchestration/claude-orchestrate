#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLAUDE ENHANCED WRAPPER v2.0 - SMART TASK ROUTER
# 
# Lightweight intelligent wrapper that:
# â€¢ Auto-detects task complexity
# â€¢ Suggests optimal execution strategy  
# â€¢ Provides quick access to orchestration
# â€¢ Learns from usage patterns
# â€¢ Minimal overhead for simple tasks
# 
# Version: 2.0 - Smart Router Architecture
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -euo pipefail

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# CONFIGURATION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SCRIPT_VERSION="2.0-smart"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Intelligent project root detection
find_project_root() {
    local dir="$SCRIPT_DIR"
    while [ "$dir" != "/" ]; do
        [ -d "$dir/agents" ] && echo "$dir" && return 0
        dir="$(dirname "$dir")"
    done
    
    # Fallback locations
    for fallback in "$HOME/Documents/Claude" "$HOME/.local/share/claude"; do
        [ -d "$fallback/agents" ] && echo "$fallback" && return 0
    done
    
    echo "$HOME/.local/share/claude"
}

PROJECT_ROOT="$(find_project_root)"
ORCHESTRATOR="$PROJECT_ROOT/agents/src/python/tandem_orchestrator.py"
CACHE_DIR="$HOME/.cache/claude-enhanced"
PATTERNS_FILE="$CACHE_DIR/patterns.json"
QUICK_ACCESS_FILE="$CACHE_DIR/quick_access.txt"

# Settings
AUTO_SUGGEST=${CLAUDE_AUTO_SUGGEST:-true}
LEARNING_MODE=${CLAUDE_LEARNING:-true}
QUICK_MODE=${CLAUDE_QUICK:-false}
THRESHOLD_SCORE=${CLAUDE_THRESHOLD:-15}

# Colors
readonly CYAN='\033[0;36m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly DIM='\033[2m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# Icons
readonly BRAIN="ğŸ§ "
readonly ROCKET="ğŸš€"
readonly GEAR="âš™ï¸"
readonly CHECK="âœ“"
readonly LIGHTBULB="ğŸ’¡"
readonly CHART="ğŸ“Š"

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# INITIALIZATION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

init() {
    mkdir -p "$CACHE_DIR"
    
    # Initialize patterns file
    if [ ! -f "$PATTERNS_FILE" ]; then
        cat > "$PATTERNS_FILE" << 'EOF'
{
  "patterns": {
    "simple": ["fix", "update", "change", "modify", "adjust", "tweak"],
    "moderate": ["implement", "add", "integrate", "setup", "configure"],
    "complex": ["architect", "design", "refactor", "optimize", "migrate"],
    "multi_agent": ["test.*deploy", "review.*fix", "document.*code", "security.*audit"]
  },
  "user_preferences": {},
  "task_history": []
}
EOF
    fi
    
    # Initialize quick access
    if [ ! -f "$QUICK_ACCESS_FILE" ]; then
        cat > "$QUICK_ACCESS_FILE" << 'EOF'
# Quick Access Commands (edit this file to customize)
# Format: alias|command|description
qa|claude /task "run quality assurance tests"|Quality assurance
sec|orchestrator --mode security|Security audit
dev|claude /task "development workflow"|Development
doc|claude /task "generate documentation"|Documentation
EOF
    fi
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# SMART TASK ANALYZER
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

analyze_task_smart() {
    local task="$1"
    
    python3 << EOF
import json
import re
import sys
from datetime import datetime

task = '''$task'''
patterns_file = '$PATTERNS_FILE'

# Load patterns and history
with open(patterns_file, 'r') as f:
    data = json.load(f)

patterns = data['patterns']
history = data.get('task_history', [])

# Scoring system
score = 0
confidence = 0
suggested_mode = 'claude'
reason = []

# Check against patterns
task_lower = task.lower()

# Simple patterns (negative score - prefer Claude)
for pattern in patterns.get('simple', []):
    if pattern in task_lower:
        score -= 5
        reason.append(f'Simple task: {pattern}')

# Moderate patterns
for pattern in patterns.get('moderate', []):
    if pattern in task_lower:
        score += 10
        reason.append(f'Moderate complexity: {pattern}')

# Complex patterns
for pattern in patterns.get('complex', []):
    if pattern in task_lower:
        score += 20
        reason.append(f'Complex task: {pattern}')

# Multi-agent patterns (regex)
for pattern in patterns.get('multi_agent', []):
    if re.search(pattern, task_lower):
        score += 30
        reason.append(f'Multi-agent workflow: {pattern}')

# Check task length and structure
word_count = len(task.split())
if word_count > 20:
    score += 10
    reason.append('Detailed requirements')

# Check for multiple steps
if any(indicator in task_lower for indicator in ['then', 'after', 'followed by', 'next', 'finally']):
    score += 15
    reason.append('Multi-step process')

# Learn from history
similar_tasks = [h for h in history if any(word in h['task'].lower() for word in task_lower.split()[:3])]
if similar_tasks:
    recent = similar_tasks[-1]
    if recent['mode'] == 'orchestrated':
        confidence += 20
        reason.append(f"Similar to previous orchestrated task")

# Determine suggestion
if score >= $THRESHOLD_SCORE:
    suggested_mode = 'orchestrate'
    confidence = min(90, 50 + score)
elif score >= 10:
    suggested_mode = 'hybrid'
    confidence = 40 + score
else:
    suggested_mode = 'claude'
    confidence = max(10, 70 - abs(score))

# Output
result = {
    'score': score,
    'mode': suggested_mode,
    'confidence': confidence,
    'reasons': reason[:3],  # Top 3 reasons
    'word_count': word_count,
    'estimated_time': max(5, min(60, word_count * 2 + score))
}

print(json.dumps(result))
EOF
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# QUICK SUGGESTION UI
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

show_quick_suggestion() {
    local task="$1"
    local analysis="$2"
    
    # Parse analysis
    local mode=$(echo "$analysis" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['mode'])")
    local confidence=$(echo "$analysis" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['confidence'])")
    local reasons=$(echo "$analysis" | python3 -c "import sys,json; r=json.loads(sys.stdin.read())['reasons']; print(' â€¢ '.join(r) if r else 'Standard task')")
    local time=$(echo "$analysis" | python3 -c "import sys,json; print(json.loads(sys.stdin.read())['estimated_time'])")
    
    # Don't suggest for simple tasks unless forced
    if [ "$mode" = "claude" ] && [ "$AUTO_SUGGEST" = "true" ]; then
        return 1
    fi
    
    # Quick suggestion bar
    echo -e "\n${CYAN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "${CYAN}â”‚ ${BRAIN} ${BOLD}Smart Analysis Complete${NC}${CYAN}                              â”‚${NC}"
    echo -e "${CYAN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
    
    # Show confidence meter
    local conf_bar=""
    local conf_color="$GREEN"
    if [ $confidence -lt 30 ]; then
        conf_bar="â–°â–±â–±â–±â–±"
        conf_color="$DIM"
    elif [ $confidence -lt 50 ]; then
        conf_bar="â–°â–°â–±â–±â–±"
        conf_color="$YELLOW"
    elif [ $confidence -lt 70 ]; then
        conf_bar="â–°â–°â–°â–±â–±"
        conf_color="$CYAN"
    elif [ $confidence -lt 90 ]; then
        conf_bar="â–°â–°â–°â–°â–±"
        conf_color="$GREEN"
    else
        conf_bar="â–°â–°â–°â–°â–°"
        conf_color="$GREEN"
    fi
    
    echo -e "${LIGHTBULB} Analysis: ${DIM}$reasons${NC}"
    echo -e "${CHART} Confidence: ${conf_color}$conf_bar${NC} ${confidence}%"
    echo -e "â±ï¸  Estimated: ~${time} minutes"
    
    # Suggestion based on mode
    case "$mode" in
        orchestrate)
            echo -e "\n${GREEN}${ROCKET} ${BOLD}Recommendation: Use Orchestration${NC}"
            echo -e "${DIM}This task would benefit from multiple specialized agents${NC}"
            echo
            echo -e "  ${GREEN}[Enter]${NC} ${CHECK} Accept (launch orchestrator)"
            echo -e "  ${YELLOW}[c]${NC}     Continue with regular Claude"
            echo -e "  ${CYAN}[h]${NC}     Hybrid mode"
            echo -e "  ${DIM}[?]${NC}     ${DIM}More info${NC}"
            ;;
        hybrid)
            echo -e "\n${YELLOW}${GEAR} ${BOLD}Suggestion: Hybrid Mode Available${NC}"
            echo -e "${DIM}This task could benefit from selective agent assistance${NC}"
            echo
            echo -e "  ${YELLOW}[Enter]${NC} Continue with Claude"
            echo -e "  ${GREEN}[o]${NC}     ${CHECK} Use orchestration"
            echo -e "  ${CYAN}[h]${NC}     Hybrid mode"
            ;;
        *)
            return 1
            ;;
    esac
    
    # Read user choice with timeout
    local choice
    read -t 5 -n 1 -s choice || choice=""
    
    case "$choice" in
        ""|$'\n')
            if [ "$mode" = "orchestrate" ]; then
                return 0  # Proceed with orchestration
            else
                return 1  # Continue with Claude
            fi
            ;;
        c|C)
            return 1  # Continue with Claude
            ;;
        o|O)
            return 0  # Use orchestration
            ;;
        h|H)
            return 2  # Hybrid mode
            ;;
        "?")
            show_detailed_analysis "$analysis"
            return $(show_quick_suggestion "$task" "$analysis")
            ;;
        *)
            return 1  # Default to Claude
            ;;
    esac
}

show_detailed_analysis() {
    local analysis="$1"
    
    echo
    echo -e "${CYAN}${BOLD}Detailed Task Analysis:${NC}"
    echo "$analysis" | python3 -c "
import sys, json
data = json.loads(sys.stdin.read())
print(f\"Score: {data['score']} points\")
print(f\"Word count: {data['word_count']}\")
print(f\"Suggested mode: {data['mode']}\")
print(f\"Confidence: {data['confidence']}%\")
print(f\"Estimated time: {data['estimated_time']} minutes\")
print(\"\\nReasons:\")
for r in data.get('reasons', []):
    print(f\"  â€¢ {r}\")
"
    echo
    echo "Press any key to continue..."
    read -n 1 -s
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# LEARNING SYSTEM
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

learn_from_execution() {
    local task="$1"
    local mode="$2"
    local user_choice="$3"
    
    [ "$LEARNING_MODE" != "true" ] && return
    
    python3 << EOF
import json
from datetime import datetime

patterns_file = '$PATTERNS_FILE'

# Load current data
with open(patterns_file, 'r') as f:
    data = json.load(f)

# Add to history
data['task_history'].append({
    'task': '''$task''',
    'mode': '$mode',
    'user_choice': '$user_choice',
    'timestamp': datetime.now().isoformat()
})

# Keep only last 100 entries
data['task_history'] = data['task_history'][-100:]

# Learn patterns (simple learning - can be enhanced)
task_lower = '''$task'''.lower()
if '$user_choice' == 'orchestrate' and '$mode' == 'claude':
    # User chose orchestration for simple task - learn this pattern
    words = task_lower.split()[:3]
    if words and words[0] not in data['patterns'].get('multi_agent', []):
        data['patterns'].setdefault('learned', []).append(' '.join(words))

# Save updated data
with open(patterns_file, 'w') as f:
    json.dump(data, f, indent=2)
EOF
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# QUICK ACCESS SYSTEM
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

handle_quick_access() {
    local cmd="$1"
    
    # Check if it's a quick access command
    if [ -f "$QUICK_ACCESS_FILE" ]; then
        while IFS='|' read -r alias command description; do
            [[ "$alias" =~ ^#.*$ ]] && continue  # Skip comments
            [ -z "$alias" ] && continue  # Skip empty lines
            
            if [ "$cmd" = "$alias" ]; then
                echo -e "${CYAN}Quick Access: ${NC}$description"
                eval "$command"
                exit $?
            fi
        done < "$QUICK_ACCESS_FILE"
    fi
    
    return 1
}

show_quick_access_menu() {
    echo -e "${CYAN}${BOLD}Quick Access Commands:${NC}"
    echo
    
    if [ -f "$QUICK_ACCESS_FILE" ]; then
        while IFS='|' read -r alias command description; do
            [[ "$alias" =~ ^#.*$ ]] && continue
            [ -z "$alias" ] && continue
            printf "  ${GREEN}%-8s${NC} %s\n" "$alias" "$description"
        done < "$QUICK_ACCESS_FILE"
    fi
    
    echo
    echo -e "${DIM}Edit $QUICK_ACCESS_FILE to customize${NC}"
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# EXECUTION HANDLERS
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

execute_claude() {
    # Find actual Claude binary
    local claude_bin=""
    for loc in \
        "$(which claude 2>/dev/null)" \
        "$(which claude-code 2>/dev/null)" \
        "$HOME/.local/npm-global/bin/claude" \
        "$HOME/.local/bin/claude.original"
    do
        if [ -f "$loc" ] && [ -x "$loc" ] && [ "$loc" != "$0" ]; then
            claude_bin="$loc"
            break
        fi
    done
    
    if [ -z "$claude_bin" ]; then
        echo -e "${YELLOW}Claude Code not found!${NC}"
        echo "Install with: npm install -g @anthropic-ai/claude-code"
        exit 1
    fi
    
    exec "$claude_bin" "$@"
}

execute_orchestrator() {
    if [ ! -f "$ORCHESTRATOR" ]; then
        echo -e "${YELLOW}Orchestrator not found!${NC}"
        echo "Expected at: $ORCHESTRATOR"
        echo "Falling back to Claude..."
        execute_claude "$@"
        return
    fi
    
    cd "$(dirname "$ORCHESTRATOR")"
    exec python3 "$(basename "$ORCHESTRATOR")" "$@"
}

execute_hybrid() {
    local task="$1"
    
    echo -e "${CYAN}${BOLD}Hybrid Mode${NC}"
    echo "Starting with Claude, orchestration available on demand"
    echo
    
    # Set environment for hybrid execution
    export CLAUDE_HYBRID_MODE=true
    export CLAUDE_ORCHESTRATOR="$ORCHESTRATOR"
    
    execute_claude "$@"
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# MAIN ROUTER
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

main() {
    # Initialize
    init
    
    # Handle special commands
    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --quick|-q)
            show_quick_access_menu
            exit 0
            ;;
        --status)
            show_status
            exit 0
            ;;
        --reset)
            rm -rf "$CACHE_DIR"
            echo "Cache reset. Learning data cleared."
            exit 0
            ;;
        --version|-v)
            echo "Claude Enhanced v$SCRIPT_VERSION"
            exit 0
            ;;
    esac
    
    # Check for quick access commands
    handle_quick_access "${1:-}" && exit 0
    
    # Quick mode - skip all analysis
    if [ "$QUICK_MODE" = "true" ]; then
        execute_claude "$@"
        exit $?
    fi
    
    # Detect task commands
    local is_task=false
    local task_text=""
    
    if [ "${1:-}" = "/task" ] || [ "${1:-}" = "task" ]; then
        is_task=true
        shift
        task_text="$*"
    fi
    
    # Analyze and route tasks
    if [ "$is_task" = true ] && [ -n "$task_text" ]; then
        # Perform smart analysis
        local analysis=$(analyze_task_smart "$task_text")
        
        # Show suggestion if appropriate
        if show_quick_suggestion "$task_text" "$analysis"; then
            local result=$?
            
            case $result in
                0)  # Orchestrate
                    learn_from_execution "$task_text" "orchestrate" "orchestrate"
                    execute_orchestrator "/task" "$task_text"
                    ;;
                2)  # Hybrid
                    learn_from_execution "$task_text" "hybrid" "hybrid"
                    execute_hybrid "/task" "$task_text"
                    ;;
                *)  # Claude
                    learn_from_execution "$task_text" "claude" "claude"
                    execute_claude "/task" "$task_text"
                    ;;
            esac
        else
            # No suggestion shown or declined - use Claude
            execute_claude "/task" "$task_text"
        fi
    else
        # Non-task command - pass through
        execute_claude "$@"
    fi
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# HELP & STATUS
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

show_help() {
    cat << EOF
${CYAN}${BOLD}Claude Enhanced v$SCRIPT_VERSION${NC}
Smart Task Router with Learning

${BOLD}USAGE:${NC}
  claude [command] [options]

${BOLD}FEATURES:${NC}
  â€¢ Intelligent task complexity detection
  â€¢ Learns from your choices over time
  â€¢ Quick access to common workflows
  â€¢ Minimal overhead for simple tasks
  â€¢ Smart orchestration suggestions

${BOLD}OPTIONS:${NC}
  --help, -h       Show this help
  --quick, -q      Show quick access menu
  --status         Show system status
  --reset          Clear learning data
  --version        Show version

${BOLD}ENVIRONMENT:${NC}
  CLAUDE_AUTO_SUGGEST=false   Disable auto suggestions
  CLAUDE_LEARNING=false        Disable learning
  CLAUDE_QUICK=true           Quick mode (skip analysis)
  CLAUDE_THRESHOLD=20         Orchestration threshold (default: 15)

${BOLD}QUICK ACCESS:${NC}
  Edit: $QUICK_ACCESS_FILE
  
  Example entries:
    qa|orchestrator --test|Run tests
    dev|claude /task "development"|Development

${BOLD}EXAMPLES:${NC}
  ${DIM}# Smart routing based on complexity${NC}
  claude /task "create feature with tests"
  
  ${DIM}# Force quick mode${NC}
  CLAUDE_QUICK=true claude /task "anything"
  
  ${DIM}# Use quick access${NC}
  claude qa  ${DIM}# Runs predefined QA workflow${NC}

${BOLD}PROJECT:${NC} $PROJECT_ROOT
EOF
}

show_status() {
    echo -e "${CYAN}${BOLD}Claude Enhanced Status${NC}"
    echo
    
    # System check
    echo "System:"
    
    # Claude
    local claude_found=false
    for loc in "$(which claude 2>/dev/null)" "$(which claude-code 2>/dev/null)"; do
        if [ -n "$loc" ] && [ -f "$loc" ]; then
            echo -e "  Claude: ${GREEN}${CHECK}${NC} Found at $loc"
            claude_found=true
            break
        fi
    done
    [ "$claude_found" = false ] && echo -e "  Claude: ${YELLOW}âœ—${NC} Not found"
    
    # Orchestrator
    if [ -f "$ORCHESTRATOR" ]; then
        echo -e "  Orchestrator: ${GREEN}${CHECK}${NC} Available"
    else
        echo -e "  Orchestrator: ${YELLOW}âœ—${NC} Not found"
    fi
    
    # Settings
    echo
    echo "Settings:"
    echo "  Auto-suggest: $AUTO_SUGGEST"
    echo "  Learning: $LEARNING_MODE"
    echo "  Quick mode: $QUICK_MODE"
    echo "  Threshold: $THRESHOLD_SCORE"
    
    # Learning data
    if [ -f "$PATTERNS_FILE" ]; then
        local task_count=$(python3 -c "import json; d=json.load(open('$PATTERNS_FILE')); print(len(d.get('task_history', [])))" 2>/dev/null || echo 0)
        echo
        echo "Learning Data:"
        echo "  Tasks analyzed: $task_count"
        echo "  Cache location: $CACHE_DIR"
    fi
    
    # Quick access
    if [ -f "$QUICK_ACCESS_FILE" ]; then
        local qa_count=$(grep -v '^#' "$QUICK_ACCESS_FILE" | grep -c '|' || echo 0)
        echo
        echo "Quick Access:"
        echo "  Commands defined: $qa_count"
    fi
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ENTRY POINT
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

main "$@"
