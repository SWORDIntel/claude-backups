name: NPU Bridge Binary Distribution

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'agents/src/rust/npu_coordination_bridge/**'
      - '.github/workflows/rust-npu-bridge-build.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'agents/src/rust/npu_coordination_bridge/**'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  detect-hardware:
    name: Detect Target Hardware
    runs-on: ubuntu-latest
    outputs:
      targets: ${{ steps.targets.outputs.matrix }}
    steps:
    - name: Define build targets
      id: targets
      run: |
        # Define target architectures with Intel NPU optimization flags
        TARGETS='[
          {
            "target": "x86_64-unknown-linux-gnu",
            "os": "ubuntu-latest",
            "features": "intel-npu,avx2,fma",
            "cpu_features": "-C target-cpu=haswell -C target-feature=+avx2,+fma",
            "description": "Intel Haswell+ (AVX2/FMA)"
          },
          {
            "target": "x86_64-unknown-linux-gnu",
            "os": "ubuntu-latest",
            "features": "intel-npu,avx512,meteor-lake",
            "cpu_features": "-C target-cpu=skylake-avx512 -C target-feature=+avx512f,+avx512dq",
            "description": "Intel Meteor Lake (AVX-512 + NPU)"
          },
          {
            "target": "x86_64-unknown-linux-musl",
            "os": "ubuntu-latest",
            "features": "intel-npu,static",
            "cpu_features": "-C target-cpu=x86-64-v2",
            "description": "Static Linux (Portable)"
          }
        ]'
        echo "matrix=$TARGETS" >> $GITHUB_OUTPUT

  build-binaries:
    name: Build NPU Bridge (${{ matrix.description }})
    needs: detect-hardware
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.detect-hardware.outputs.targets) }}
    runs-on: ${{ matrix.os }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        targets: ${{ matrix.target }}
        components: rustfmt, clippy

    - name: Install musl tools (if needed)
      if: contains(matrix.target, 'musl')
      run: |
        sudo apt-get update
        sudo apt-get install -y musl-tools

    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        workspaces: "agents/src/rust/npu_coordination_bridge"
        key: ${{ matrix.target }}-${{ matrix.features }}

    - name: Install Intel NPU development libraries
      run: |
        # Install OpenVINO and Intel NPU development headers
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          pkg-config \
          libssl-dev \
          libudev-dev

        # Download Intel OpenVINO for CI builds
        wget -q https://storage.openvinotoolkit.org/repositories/openvino/packages/2024.6/linux/l_openvino_toolkit_ubuntu20_2024.6.000.tar.gz
        tar -xzf l_openvino_toolkit_ubuntu20_2024.6.000.tar.gz
        echo "OPENVINO_ROOT=$PWD/l_openvino_toolkit_ubuntu20_2024.6.000" >> $GITHUB_ENV

    - name: Verify Rust project structure
      working-directory: agents/src/rust/npu_coordination_bridge
      run: |
        echo "=== Cargo.toml ==="
        cat Cargo.toml
        echo "=== Source structure ==="
        find src -name "*.rs" | head -10

    - name: Run Rust tests
      working-directory: agents/src/rust/npu_coordination_bridge
      env:
        RUSTFLAGS: "${{ matrix.cpu_features }} -C opt-level=3 -C lto=fat"
      run: |
        cargo test --target ${{ matrix.target }} --release --features "${{ matrix.features }}"

    - name: Build NPU bridge binary (optimized)
      working-directory: agents/src/rust/npu_coordination_bridge
      env:
        RUSTFLAGS: "${{ matrix.cpu_features }} -C opt-level=3 -C lto=fat -C codegen-units=1"
        CARGO_TARGET_DIR: "target-${{ matrix.target }}"
      run: |
        echo "Building with features: ${{ matrix.features }}"
        echo "CPU optimization flags: ${{ matrix.cpu_features }}"

        # Build the main library
        cargo build \
          --release \
          --target ${{ matrix.target }} \
          --features "${{ matrix.features }}" \
          --lib

        # Build the server binary
        cargo build \
          --release \
          --target ${{ matrix.target }} \
          --features "${{ matrix.features }}" \
          --bin server

    - name: Run performance benchmarks
      working-directory: agents/src/rust/npu_coordination_bridge
      env:
        RUSTFLAGS: "${{ matrix.cpu_features }} -C opt-level=3"
        CARGO_TARGET_DIR: "target-${{ matrix.target }}"
      run: |
        # Only run if benchmarks feature exists
        if grep -q 'required-features.*benchmarks' Cargo.toml; then
          cargo bench \
            --target ${{ matrix.target }} \
            --features "benchmarks,${{ matrix.features }}" \
            -- --output-format json > bench-results-${{ matrix.target }}.json || true
        fi

    - name: Create binary package
      working-directory: agents/src/rust/npu_coordination_bridge
      run: |
        # Determine version
        VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version')

        # Create package directory
        PACKAGE_NAME="npu-coordination-bridge-v${VERSION}-${{ matrix.target }}"
        mkdir -p "packages/${PACKAGE_NAME}"

        # Copy binaries
        cp "target-${{ matrix.target }}/${{ matrix.target }}/release/libnpu_coordination_bridge.so" "packages/${PACKAGE_NAME}/" 2>/dev/null || \
        cp "target-${{ matrix.target }}/${{ matrix.target }}/release/libnpu_coordination_bridge.dylib" "packages/${PACKAGE_NAME}/" 2>/dev/null || \
        cp "target-${{ matrix.target }}/${{ matrix.target }}/release/libnpu_coordination_bridge.dll" "packages/${PACKAGE_NAME}/" 2>/dev/null || \
        cp "target-${{ matrix.target }}/${{ matrix.target }}/release/libnpu_coordination_bridge.a" "packages/${PACKAGE_NAME}/" || true

        cp "target-${{ matrix.target }}/${{ matrix.target }}/release/server" "packages/${PACKAGE_NAME}/npu-bridge-server" 2>/dev/null || \
        cp "target-${{ matrix.target }}/${{ matrix.target }}/release/server.exe" "packages/${PACKAGE_NAME}/npu-bridge-server.exe" 2>/dev/null || true

        # Create metadata
        cat > "packages/${PACKAGE_NAME}/BUILD_INFO.json" << EOF
        {
          "version": "${VERSION}",
          "target": "${{ matrix.target }}",
          "features": "${{ matrix.features }}",
          "cpu_features": "${{ matrix.cpu_features }}",
          "description": "${{ matrix.description }}",
          "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "git_commit": "${GITHUB_SHA}",
          "compiler": "$(rustc --version)"
        }
        EOF

        # Create installation script
        cat > "packages/${PACKAGE_NAME}/install.sh" << 'EOF'
        #!/bin/bash
        set -euo pipefail

        INSTALL_DIR="${1:-/usr/local}"
        BIN_DIR="${INSTALL_DIR}/bin"
        LIB_DIR="${INSTALL_DIR}/lib"

        echo "Installing NPU Coordination Bridge to ${INSTALL_DIR}"

        # Create directories
        mkdir -p "${BIN_DIR}" "${LIB_DIR}"

        # Install binaries
        if [[ -f "npu-bridge-server" ]]; then
            cp "npu-bridge-server" "${BIN_DIR}/"
            chmod +x "${BIN_DIR}/npu-bridge-server"
            echo "Installed server binary to ${BIN_DIR}/npu-bridge-server"
        fi

        # Install libraries
        for lib in libnpu_coordination_bridge.*; do
            if [[ -f "$lib" ]]; then
                cp "$lib" "${LIB_DIR}/"
                echo "Installed library to ${LIB_DIR}/$lib"
            fi
        done

        echo "Installation complete!"
        echo "Run 'npu-bridge-server --help' to get started"
        EOF
        chmod +x "packages/${PACKAGE_NAME}/install.sh"

        # Create tarball
        cd packages
        tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}"

        echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
        echo "VERSION=${VERSION}" >> $GITHUB_ENV

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: npu-bridge-${{ matrix.target }}-${{ env.VERSION }}
        path: |
          agents/src/rust/npu_coordination_bridge/packages/*.tar.gz
          agents/src/rust/npu_coordination_bridge/bench-results-*.json
        retention-days: 30

    - name: Upload performance results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: benchmarks-${{ matrix.target }}
        path: agents/src/rust/npu_coordination_bridge/bench-results-*.json
        retention-days: 7

  create-release:
    name: Create GitHub Release
    needs: [detect-hardware, build-binaries]
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        find artifacts -name "*.tar.gz" -exec cp {} release-assets/ \;

        # Create combined performance report
        find artifacts -name "bench-results-*.json" -exec cat {} \; > release-assets/performance-report.json || echo '{}' > release-assets/performance-report.json

        # Create checksums
        cd release-assets
        sha256sum *.tar.gz > SHA256SUMS

        echo "Release assets:"
        ls -la

    - name: Get version from Cargo.toml
      id: version
      run: |
        cd agents/src/rust/npu_coordination_bridge
        VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version')
        echo "version=v${VERSION}" >> $GITHUB_OUTPUT

    - name: Create or update release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.version.outputs.version }}
        name: NPU Coordination Bridge ${{ steps.version.outputs.version }}
        body: |
          ## NPU Coordination Bridge Release ${{ steps.version.outputs.version }}

          High-performance Rust implementation of NPU coordination bridge with Intel Meteor Lake optimization.

          ### Features
          - **50K+ operations per second** with sub-millisecond latency
          - **Intel NPU hardware integration** with OpenVINO
          - **AVX2/AVX-512 optimization** for Meteor Lake processors
          - **Zero-copy message passing** between Python and Rust
          - **Real-time coordination protocols**

          ### Installation

          **Quick install (downloads pre-built binary):**
          ```bash
          curl -sSL https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.version }}/install.sh | bash
          ```

          **Manual install:**
          1. Download the appropriate binary for your system
          2. Extract: `tar -xzf npu-coordination-bridge-*.tar.gz`
          3. Install: `cd npu-coordination-bridge-* && ./install.sh`

          ### Hardware Targets
          - **Haswell+**: Intel processors with AVX2/FMA support
          - **Meteor Lake**: Intel Core Ultra with NPU (recommended)
          - **Portable**: Static musl build for broad compatibility

          ### Performance Benchmarks
          See `performance-report.json` for detailed benchmarks across all targets.

          Built with Rust ${{ env.RUST_VERSION }} on commit ${{ github.sha }}
        files: |
          release-assets/*
        draft: false
        prerelease: ${{ contains(steps.version.outputs.version, 'rc') || contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'alpha') }}

  create-install-script:
    name: Create Universal Install Script
    needs: [detect-hardware, build-binaries]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Create universal install script
      run: |
        cat > install.sh << 'EOF'
        #!/bin/bash
        set -euo pipefail

        # NPU Coordination Bridge Universal Installer
        # Automatically detects hardware and downloads optimized binary

        REPO="$GITHUB_REPOSITORY"
        INSTALL_DIR="${INSTALL_DIR:-/usr/local}"
        VERSION="${NPU_BRIDGE_VERSION:-latest}"

        # Colors for output
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        NC='\033[0m' # No Color

        log() { echo -e "${BLUE}[NPU-BRIDGE]${NC} $1"; }
        warn() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
        error() { echo -e "${RED}[ERROR]${NC} $1"; exit 1; }
        success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }

        # Detect hardware capabilities
        detect_hardware() {
            log "Detecting hardware capabilities..."

            local cpu_info="/proc/cpuinfo"
            local target="x86_64-unknown-linux-gnu"
            local features="intel-npu"

            if [[ -f "$cpu_info" ]]; then
                if grep -q "avx512" "$cpu_info"; then
                    features="intel-npu,avx512,meteor-lake"
                    log "Detected Intel processor with AVX-512 (Meteor Lake optimized)"
                elif grep -q "avx2" "$cpu_info"; then
                    features="intel-npu,avx2,fma"
                    log "Detected Intel processor with AVX2/FMA (Haswell+ optimized)"
                else
                    warn "No advanced vector extensions detected, using portable build"
                    target="x86_64-unknown-linux-musl"
                    features="intel-npu,static"
                fi
            fi

            # Check for Intel NPU
            if [[ -d "/sys/class/drm" ]] && find /sys/class/drm -name "*intel*" | grep -q .; then
                log "Intel graphics detected - NPU support likely available"
            elif lspci 2>/dev/null | grep -qi "intel.*npu\|intel.*neural"; then
                log "Intel NPU hardware detected"
            else
                warn "No Intel NPU detected - functionality may be limited"
            fi

            echo "$target:$features"
        }

        # Get latest release version
        get_latest_version() {
            if [[ "$VERSION" == "latest" ]]; then
                log "Fetching latest release version..."
                VERSION=$(curl -sSL "https://api.github.com/repos/$REPO/releases/latest" | \
                         grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
                log "Latest version: $VERSION"
            fi
            echo "$VERSION"
        }

        # Download and install
        install_npu_bridge() {
            local hardware_info
            hardware_info=$(detect_hardware)
            local target
            target=$(echo "$hardware_info" | cut -d: -f1)
            local features
            features=$(echo "$hardware_info" | cut -d: -f2)

            local version
            version=$(get_latest_version)

            local package_name="npu-coordination-bridge-${version}-${target}"
            local download_url="https://github.com/$REPO/releases/download/$version/${package_name}.tar.gz"

            log "Downloading NPU bridge: $package_name"
            log "Target: $target"
            log "Features: $features"
            log "Download URL: $download_url"

            # Create temporary directory
            local temp_dir
            temp_dir=$(mktemp -d)
            trap "rm -rf $temp_dir" EXIT

            # Download with retry logic
            local max_attempts=3
            local attempt=1

            while [[ $attempt -le $max_attempts ]]; do
                log "Download attempt $attempt/$max_attempts..."

                if curl -sSL -f "$download_url" -o "$temp_dir/package.tar.gz"; then
                    log "Download successful"
                    break
                elif [[ $attempt -eq $max_attempts ]]; then
                    error "Failed to download after $max_attempts attempts"
                else
                    warn "Download failed, retrying in 2 seconds..."
                    sleep 2
                    ((attempt++))
                fi
            done

            # Extract and install
            log "Extracting package..."
            cd "$temp_dir"
            tar -xzf package.tar.gz

            cd "$package_name"

            log "Installing to $INSTALL_DIR..."
            if [[ $EUID -eq 0 ]]; then
                ./install.sh "$INSTALL_DIR"
            else
                log "Running installation with sudo..."
                sudo ./install.sh "$INSTALL_DIR"
            fi

            success "NPU Coordination Bridge installed successfully!"

            # Verify installation
            if command -v npu-bridge-server >/dev/null 2>&1; then
                log "Verifying installation..."
                npu-bridge-server --version || true
                success "Installation verified!"
            else
                warn "Binary not found in PATH. You may need to add $INSTALL_DIR/bin to your PATH"
            fi
        }

        # Performance test
        run_performance_test() {
            if command -v npu-bridge-server >/dev/null 2>&1; then
                log "Running performance test..."
                timeout 10s npu-bridge-server --benchmark --duration 5000 || true
            fi
        }

        # Main installation
        main() {
            log "NPU Coordination Bridge Universal Installer"
            log "Repository: $REPO"
            log "Install directory: $INSTALL_DIR"

            # Check dependencies
            for cmd in curl tar; do
                if ! command -v "$cmd" >/dev/null 2>&1; then
                    error "Required command not found: $cmd"
                fi
            done

            install_npu_bridge

            # Optional performance test
            if [[ "${RUN_TEST:-}" == "1" ]]; then
                run_performance_test
            fi

            success "Setup complete! üöÄ"
            log "Run 'npu-bridge-server --help' to get started"
        }

        main "$@"
        EOF

        # Make executable and substitute GitHub repository
        chmod +x install.sh
        sed -i "s/\$GITHUB_REPOSITORY/${{ github.repository }}/g" install.sh

    - name: Upload install script as release asset
      if: github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        files: install.sh

  integration-test:
    name: Integration Test
    needs: build-binaries
    runs-on: ubuntu-latest

    steps:
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: npu-bridge-x86_64-unknown-linux-gnu-*
        path: test-artifacts

    - name: Test binary installation
      run: |
        # Find the downloaded package
        PACKAGE=$(find test-artifacts -name "*.tar.gz" | head -1)

        if [[ -n "$PACKAGE" ]]; then
          echo "Testing package: $PACKAGE"

          # Extract and test install
          tar -xzf "$PACKAGE"
          cd npu-coordination-bridge-*

          # Test installation script
          ./install.sh "$HOME/test-install"

          # Verify binaries exist
          if [[ -f "$HOME/test-install/bin/npu-bridge-server" ]]; then
            echo "‚úÖ Server binary installed successfully"
            "$HOME/test-install/bin/npu-bridge-server" --version || echo "Binary may need runtime dependencies"
          else
            echo "‚ùå Server binary not found"
            exit 1
          fi
        else
          echo "‚ö†Ô∏è No packages found to test"
        fi

  cleanup:
    name: Cleanup Old Releases
    needs: create-release
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Delete old pre-releases
      uses: dev-drprasad/delete-older-releases@v0.3.2
      with:
        keep_latest: 5
        delete_tags: true
        delete_tag_pattern: ".*-rc.*|.*-beta.*|.*-alpha.*"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}