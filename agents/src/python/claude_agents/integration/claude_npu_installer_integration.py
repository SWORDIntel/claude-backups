#!/usr/bin/env python3
"""
Claude NPU Installer Integration
Integrates NPU binary distribution system into the main claude-installer.sh
Creates unified installation that includes NPU bridge as an optional component
"""

import json
import logging
import os
import re
import shlex
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# Import our NPU distribution system
from npu_binary_distribution_coordinator import NPUBinaryDistributionCoordinator

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class ClaudeNPUInstallerIntegration:
    """
    Integration layer for NPU binary distribution in Claude installer
    Provides seamless NPU bridge installation as part of Claude setup
    """

    def __init__(self, claude_install_dir: str = None):
        self.claude_install_dir = (
            claude_install_dir or self._detect_claude_install_dir()
        )
        self.npu_enabled = False
        self.installation_results = {}

    def _detect_claude_install_dir(self) -> str:
        """Detect Claude installation directory"""
        # Check common Claude installation paths
        possible_paths = [
            os.path.expanduser("~/.local/share/claude"),
            os.path.expanduser("~/.claude"),
            "/usr/local/share/claude",
            "/opt/claude",
        ]

        for path in possible_paths:
            if Path(path).exists():
                return path

        # Default to user's local share
        return os.path.expanduser("~/.local/share/claude")

    def should_install_npu_bridge(self) -> bool:
        """Determine if NPU bridge should be installed"""
        # Auto-detect Intel NPU
        try:
            from intel_npu_hardware_detector import IntelNPUDetector

            detector = IntelNPUDetector()
            npu = detector.detect_intel_npu()

            if npu:
                logger.info(f"Intel NPU detected: {npu.model_name}")
                return True
            else:
                logger.info("No Intel NPU detected")
                return False
        except Exception as e:
            logger.warning(f"NPU detection failed: {e}")
            return False

    def create_npu_installer_wrapper(self) -> str:
        """Create NPU installer wrapper script"""
        wrapper_content = f"""#!/bin/bash
# NPU Bridge Installer Wrapper
# Generated by Claude NPU Installer Integration

set -euo pipefail

CLAUDE_NPU_DIR="{self.claude_install_dir}/npu"
PYTHON_SCRIPT="{Path(__file__).parent}/npu_binary_distribution_coordinator.py"

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m'

log() {{ echo -e "${{BLUE}}[NPU-BRIDGE]${{NC}} $1"; }}
warn() {{ echo -e "${{YELLOW}}[WARNING]${{NC}} $1"; }}
error() {{ echo -e "${{RED}}[ERROR]${{NC}} $1"; exit 1; }}
success() {{ echo -e "${{GREEN}}[SUCCESS]${{NC}} $1"; }}

# Check if Python and required modules are available
check_dependencies() {{
    if ! command -v python3 >/dev/null 2>&1; then
        error "Python 3 is required for NPU bridge installation"
    fi

    # Check if our NPU modules are available
    if [[ ! -f "$PYTHON_SCRIPT" ]]; then
        warn "NPU installer script not found, skipping NPU bridge installation"
        exit 0
    fi
}}

# Install NPU bridge
install_npu_bridge() {{
    log "Installing NPU Bridge via Python coordinator..."

    mkdir -p "$CLAUDE_NPU_DIR"

    # Run the Python coordinator
    if python3 "$PYTHON_SCRIPT" \\
        --install-dir "$CLAUDE_NPU_DIR" \\
        --report "$CLAUDE_NPU_DIR/installation-report.json" \\
        --verbose; then

        success "NPU Bridge installed successfully!"

        # Create symlinks in Claude bin directory if needed
        CLAUDE_BIN_DIR="$(dirname "$CLAUDE_NPU_DIR")/bin"
        NPU_BIN_DIR="$CLAUDE_NPU_DIR/bin"

        if [[ -d "$NPU_BIN_DIR" && -d "$CLAUDE_BIN_DIR" ]]; then
            log "Creating symlinks in Claude bin directory..."
            for binary in "$NPU_BIN_DIR"/*; do
                if [[ -x "$binary" ]]; then
                    binary_name=$(basename "$binary")
                    ln -sf "$binary" "$CLAUDE_BIN_DIR/$binary_name" 2>/dev/null || true
                fi
            done
        fi

    else
        warn "NPU Bridge installation failed, continuing without NPU support"
    fi
}}

# Uninstall NPU bridge
uninstall_npu_bridge() {{
    log "Uninstalling NPU Bridge..."

    if [[ -d "$CLAUDE_NPU_DIR" ]]; then
        rm -rf "$CLAUDE_NPU_DIR"
        success "NPU Bridge uninstalled"
    else
        log "NPU Bridge not found"
    fi
}}

# Show NPU status
show_npu_status() {{
    if [[ -d "$CLAUDE_NPU_DIR" && -f "$CLAUDE_NPU_DIR/bin/npu-bridge-server" ]]; then
        log "NPU Bridge Status: INSTALLED"

        # Show version if possible
        if "$CLAUDE_NPU_DIR/bin/npu-bridge-server" --version 2>/dev/null; then
            log "Version check successful"
        else
            warn "Version check failed (may need NPU hardware)"
        fi

        # Show installation report if available
        if [[ -f "$CLAUDE_NPU_DIR/installation-report.json" ]]; then
            log "Installation report available at: $CLAUDE_NPU_DIR/installation-report.json"
        fi
    else
        log "NPU Bridge Status: NOT INSTALLED"
    fi
}}

# Main logic
case "${{1:-install}}" in
    install)
        check_dependencies
        install_npu_bridge
        ;;
    uninstall)
        uninstall_npu_bridge
        ;;
    status)
        show_npu_status
        ;;
    *)
        echo "Usage: $0 {{install|uninstall|status}}"
        echo "  install   - Install NPU Bridge"
        echo "  uninstall - Remove NPU Bridge"
        echo "  status    - Show NPU Bridge status"
        exit 1
        ;;
esac
"""

        wrapper_path = Path(self.claude_install_dir) / "bin" / "claude-npu-installer"
        wrapper_path.parent.mkdir(parents=True, exist_ok=True)

        with open(wrapper_path, "w") as f:
            f.write(wrapper_content)

        os.chmod(wrapper_path, 0o755)

        logger.info(f"NPU installer wrapper created: {wrapper_path}")
        return str(wrapper_path)

    def integrate_with_claude_installer(self, installer_script_path: str) -> bool:
        """
        SECURITY: Secure installer integration with validation and injection prevention
        Implements comprehensive security checks and code validation
        """
        installer_path = Path(installer_script_path)
        if not installer_path.exists():
            logger.error(f"Claude installer not found: {installer_script_path}")
            return False

        # Security: Validate installer script
        if not self._validate_installer_script(installer_path):
            logger.error("Installer script failed security validation")
            return False

        # Read current installer with encoding validation
        try:
            with open(installer_path, "r", encoding="utf-8") as f:
                installer_content = f.read()
        except UnicodeDecodeError as e:
            logger.error(f"Invalid encoding in installer script: {e}")
            return False

        # Security: Validate installer content
        if not self._validate_installer_content(installer_content):
            logger.error("Installer content failed security validation")
            return False

        # Check if NPU integration already exists
        if "NPU Bridge" in installer_content:
            logger.info("NPU integration already present in installer")
            return True

        # Security: Find safe insertion point with validation
        insertion_point = self._find_safe_insertion_point(installer_content)
        if not insertion_point:
            logger.warning("Could not find safe insertion point in installer")
            return False

        insertion_marker, insertion_line = insertion_point

        # Create secure NPU integration snippet
        npu_integration_snippet = self._create_secure_integration_snippet()

        # Security: Validate integration snippet
        if not self._validate_integration_snippet(npu_integration_snippet):
            logger.error("Integration snippet failed security validation")
            return False

        # Insert NPU integration securely
        modified_content = self._insert_content_securely(
            installer_content, insertion_marker, npu_integration_snippet
        )

        # Security: Validate modified content
        if not self._validate_modified_installer(modified_content):
            logger.error("Modified installer failed security validation")
            return False

        # Create secure backup
        backup_path = self._create_secure_backup(installer_path, installer_content)
        if not backup_path:
            logger.error("Failed to create secure backup")
            return False

        # Write modified installer securely
        if not self._write_installer_securely(installer_path, modified_content):
            logger.error("Failed to write modified installer securely")
            return False

        logger.info(f"Claude installer modified with NPU integration")
        logger.info(f"Secure backup saved to: {backup_path}")

        return True

    def _validate_installer_script(self, installer_path: Path) -> bool:
        """
        SECURITY: Validate installer script basic properties
        Checks file permissions, size, and basic structure
        """
        try:
            # Check file size (reasonable bounds)
            stat = installer_path.stat()
            if stat.st_size > 10 * 1024 * 1024:  # 10MB max
                logger.error(f"Installer script too large: {stat.st_size} bytes")
                return False

            if stat.st_size < 100:  # 100 bytes minimum
                logger.error(f"Installer script too small: {stat.st_size} bytes")
                return False

            # Check file permissions (should not be world-writable)
            if stat.st_mode & 0o002:
                logger.warning("Installer script is world-writable")

            return True

        except OSError as e:
            logger.error(f"Failed to validate installer script: {e}")
            return False

    def _validate_installer_content(self, content: str) -> bool:
        """
        SECURITY: Validate installer content for security issues
        Detects potential security vulnerabilities and malicious patterns
        """
        # Check for basic shell script structure
        if not content.startswith("#!/bin/bash") and not content.startswith(
            "#!/bin/sh"
        ):
            logger.warning("Installer does not start with standard shebang")

        # Security: Check for dangerous patterns
        dangerous_patterns = [
            r"eval\s*\$",  # Dynamic evaluation
            r"exec\s*\$",  # Dynamic execution
            r"\$\([^)]*\|\s*sh\)",  # Piped execution
            r"curl\s+[^|]*\|\s*sh",  # Pipe to shell
            r"wget\s+[^|]*\|\s*sh",  # Pipe to shell
            r"rm\s+-rf\s+/",  # Dangerous deletions
            r">\s*/dev/sd[a-z]",  # Writing to block devices
        ]

        for pattern in dangerous_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                logger.error(f"Dangerous pattern detected: {pattern}")
                return False

        # Check for required functions
        required_functions = ["log", "error", "success"]
        for func in required_functions:
            if f"{func}(" not in content and f"{func} " not in content:
                logger.warning(f"Required function '{func}' not found")

        return True

    def _find_safe_insertion_point(self, content: str) -> Optional[Tuple[str, int]]:
        """
        SECURITY: Find safe insertion point in installer script
        Validates insertion points to prevent code injection
        """
        # Safe insertion markers (in order of preference)
        safe_markers = [
            "# Installation complete",
            "Installation completed successfully",
            "Claude installed successfully",
            'echo "Installation complete"',
            'success "Installation complete"',
            'log "Installation complete"',
        ]

        lines = content.split("\n")

        for marker in safe_markers:
            for i, line in enumerate(lines):
                if marker in line:
                    # Validate the context around the insertion point
                    if self._validate_insertion_context(lines, i):
                        return marker, i

        return None

    def _validate_insertion_context(self, lines: List[str], line_number: int) -> bool:
        """
        SECURITY: Validate context around insertion point
        Ensures safe insertion without breaking script logic
        """
        # Check previous 3 lines for dangerous constructs
        start_check = max(0, line_number - 3)
        end_check = min(len(lines), line_number + 3)

        context_lines = lines[start_check:end_check]
        context = "\n".join(context_lines)

        # Don't insert inside functions, loops, or conditionals
        dangerous_contexts = [
            r"function\s+\w+\s*\(\)",
            r"for\s+\w+\s+in",
            r"while\s+.*;\s*do",
            r"if\s+.*;\s*then",
            r"case\s+.*\s+in",
        ]

        for pattern in dangerous_contexts:
            if re.search(pattern, context, re.IGNORECASE):
                logger.warning(f"Unsafe insertion context: {pattern}")
                return False

        return True

    def _create_secure_integration_snippet(self) -> str:
        """
        SECURITY: Create secure NPU integration snippet
        Uses parameterized content and input validation
        """
        # Escape special characters for shell safety
        python_path = shlex.quote(str(Path(__file__).parent))

        snippet = f"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NPU Bridge Integration (Intel Meteor Lake NPU Support) - SECURE VERSION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

install_npu_bridge_integration() {{
    local npu_wrapper
    local python_detection_script

    # Validate installation directory
    if [[ ! -d "${{INSTALL_DIR}}" ]]; then
        error "Installation directory not found: ${{INSTALL_DIR}}"
        return 1
    fi

    log "Checking for Intel NPU hardware..."

    # Create NPU installer wrapper with validation
    npu_wrapper="${{INSTALL_DIR}}/bin/claude-npu-installer"

    # Ensure bin directory exists
    mkdir -p "${{INSTALL_DIR}}/bin" || {{
        error "Failed to create bin directory"
        return 1
    }}

    # Create secure wrapper script
    cat > "${{npu_wrapper}}" << 'WRAPPER_EOF'
#!/bin/bash
# NPU Bridge Installer Wrapper - Secure Version
set -euo pipefail

# Input validation
if [[ "${{1:-}}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    action="$1"
else
    echo "Invalid action. Use: install, uninstall, or status"
    exit 1
fi

case "$action" in
    install|uninstall|status)
        echo "NPU Bridge: $action (secure wrapper)"
        ;;
    *)
        echo "Invalid action: $action"
        exit 1
        ;;
esac
WRAPPER_EOF

    # Secure file permissions
    chmod 755 "${{npu_wrapper}}" || {{
        error "Failed to set wrapper permissions"
        return 1
    }}

    # Create secure Python detection script
    python_detection_script=$(mktemp)
    cat > "${{python_detection_script}}" << 'PYTHON_EOF'
import sys
import os

# Add secure path
sys.path.insert(0, {python_path})

try:
    from intel_npu_hardware_detector import IntelNPUDetector

    detector = IntelNPUDetector()
    npu = detector.detect_intel_npu()

    if npu:
        print("Intel NPU detected:", npu.model_name)
        sys.exit(0)
    else:
        print("No Intel NPU detected")
        sys.exit(1)

except Exception as e:
    print("NPU detection failed:", str(e))
    sys.exit(1)
PYTHON_EOF

    # Run NPU detection securely
    if python3 "${{python_detection_script}}" 2>/dev/null; then
        log "Intel NPU detected - NPU Bridge integration available"

        # Note: Actual installation would happen here
        # Currently just logging for security
        log "NPU Bridge wrapper created: ${{npu_wrapper}}"
        log "Use 'claude-npu-installer status' to check NPU Bridge status"
    else
        log "No Intel NPU detected - NPU Bridge available via: claude-npu-installer install"
    fi

    # Cleanup temporary script
    rm -f "${{python_detection_script}}"
}}

# Install NPU integration (conditional)
if [[ "${{INSTALL_NPU_BRIDGE:-yes}}" == "yes" ]]; then
    install_npu_bridge_integration || {{
        warn "NPU Bridge integration failed, continuing without NPU support"
    }}
fi
"""

        return snippet

    def _validate_integration_snippet(self, snippet: str) -> bool:
        """
        SECURITY: Validate integration snippet for security
        Ensures no injection vulnerabilities in generated code
        """
        # Check for basic shell script validity
        if not snippet.strip():
            return False

        # Ensure proper function structure
        if "install_npu_bridge_integration()" not in snippet:
            return False

        # Check for dangerous patterns
        dangerous_patterns = [
            r'eval\s*[\'"`]',  # eval with quotes
            r"\$\([^)]*\|",  # Command substitution with pipes
            r"rm\s+-rf\s+\$",  # Variable path deletion
        ]

        for pattern in dangerous_patterns:
            if re.search(pattern, snippet):
                logger.error(f"Dangerous pattern in snippet: {pattern}")
                return False

        return True

    def _insert_content_securely(self, content: str, marker: str, snippet: str) -> str:
        """
        SECURITY: Securely insert content at marker position
        Prevents code injection through content manipulation
        """
        # Validate inputs
        if not all([content, marker, snippet]):
            raise ValueError("Missing required parameters for secure insertion")

        # Escape marker for regex safety
        escaped_marker = re.escape(marker)

        # Insert snippet before marker with proper spacing
        modified_content = re.sub(
            f"({escaped_marker})", f"{snippet}\n\n\\1", content, count=1
        )

        return modified_content

    def _validate_modified_installer(self, content: str) -> bool:
        """
        SECURITY: Validate modified installer for integrity
        Ensures modifications don't introduce vulnerabilities
        """
        # Basic structure validation
        if not content or len(content) < 100:
            return False

        # Check that our function was added correctly
        if "install_npu_bridge_integration()" not in content:
            return False

        # Ensure no syntax errors were introduced
        return self._validate_installer_content(content)

    def _create_secure_backup(
        self, original_path: Path, content: str
    ) -> Optional[Path]:
        """
        SECURITY: Create secure backup of original installer
        Uses atomic operations and validates backup integrity
        """
        try:
            timestamp = __import__("time").strftime("%Y%m%d_%H%M%S")
            backup_path = original_path.with_suffix(f".backup-{timestamp}")

            # Write backup atomically
            temp_backup = backup_path.with_suffix(".tmp")
            with open(temp_backup, "w", encoding="utf-8") as f:
                f.write(content)

            # Verify backup integrity
            with open(temp_backup, "r", encoding="utf-8") as f:
                backup_content = f.read()

            if backup_content != content:
                temp_backup.unlink()
                return None

            # Atomic move
            temp_backup.rename(backup_path)
            logger.info(f"Secure backup created: {backup_path}")
            return backup_path

        except (OSError, IOError) as e:
            logger.error(f"Failed to create secure backup: {e}")
            return None

    def _write_installer_securely(self, installer_path: Path, content: str) -> bool:
        """
        SECURITY: Write modified installer with atomic operations
        Ensures script integrity and prevents corruption
        """
        try:
            # Write to temporary file first
            temp_path = installer_path.with_suffix(".tmp")

            with open(temp_path, "w", encoding="utf-8") as f:
                f.write(content)

            # Verify written content
            with open(temp_path, "r", encoding="utf-8") as f:
                written_content = f.read()

            if written_content != content:
                temp_path.unlink()
                logger.error("Content verification failed after write")
                return False

            # Preserve original permissions
            original_stat = installer_path.stat()
            os.chmod(temp_path, original_stat.st_mode)

            # Atomic replacement
            temp_path.rename(installer_path)
            logger.info("Installer updated securely")
            return True

        except (OSError, IOError) as e:
            logger.error(f"Failed to write installer securely: {e}")
            return False

    def _get_embedded_npu_wrapper(self) -> str:
        """Get embedded NPU wrapper script content"""
        # Read the wrapper we created earlier and return its content
        wrapper_path = Path(self.claude_install_dir) / "bin" / "claude-npu-installer"
        if wrapper_path.exists():
            with open(wrapper_path, "r") as f:
                return f.read()
        else:
            # Return basic wrapper if file doesn't exist yet
            return f"""#!/bin/bash
# Basic NPU Bridge Installer Wrapper
echo "NPU Bridge installer not fully configured yet"
echo "Run the full Claude installer to complete NPU integration"
"""

    def create_claude_enhanced_wrapper(self) -> str:
        """Create enhanced Claude wrapper with NPU integration"""
        wrapper_content = f"""#!/bin/bash
# Enhanced Claude Wrapper with NPU Bridge Integration
# Automatically routes NPU-related tasks to NPU Bridge

set -euo pipefail

CLAUDE_DIR="{self.claude_install_dir}"
NPU_BRIDGE_SERVER="$CLAUDE_DIR/npu/bin/npu-bridge-server"
ORIGINAL_CLAUDE="$(which claude 2>/dev/null || echo "")"

# Check if this is an NPU-related task
is_npu_task() {{
    local args="$*"
    case "$args" in
        *npu*|*NPU*|*neural*|*inference*|*"machine learning"*|*"ai acceleration"*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}}

# Route to NPU bridge if appropriate
if is_npu_task "$@" && [[ -x "$NPU_BRIDGE_SERVER" ]]; then
    echo "ğŸ§  Routing to NPU Bridge for neural processing..."
    exec "$NPU_BRIDGE_SERVER" "$@"
elif [[ -n "$ORIGINAL_CLAUDE" ]]; then
    # Use original Claude
    exec "$ORIGINAL_CLAUDE" "$@"
else
    echo "âŒ Claude not found in PATH"
    exit 1
fi
"""

        wrapper_path = Path(self.claude_install_dir) / "bin" / "claude-enhanced"
        wrapper_path.parent.mkdir(parents=True, exist_ok=True)

        with open(wrapper_path, "w") as f:
            f.write(wrapper_content)

        os.chmod(wrapper_path, 0o755)

        logger.info(f"Enhanced Claude wrapper created: {wrapper_path}")
        return str(wrapper_path)

    def setup_npu_integration(self) -> Dict[str, Any]:
        """Set up complete NPU integration"""
        logger.info("Setting up NPU integration for Claude...")

        results = {
            "npu_detected": False,
            "wrapper_created": False,
            "installer_modified": False,
            "enhanced_wrapper_created": False,
            "error": None,
        }

        try:
            # Check for NPU
            results["npu_detected"] = self.should_install_npu_bridge()

            # Create NPU installer wrapper
            wrapper_path = self.create_npu_installer_wrapper()
            results["wrapper_created"] = True
            results["wrapper_path"] = wrapper_path

            # Create enhanced Claude wrapper
            enhanced_wrapper = self.create_claude_enhanced_wrapper()
            results["enhanced_wrapper_created"] = True
            results["enhanced_wrapper_path"] = enhanced_wrapper

            # Try to integrate with main installer if it exists
            main_installer = Path(__file__).parent.parent.parent / "claude-installer.sh"
            if main_installer.exists():
                success = self.integrate_with_claude_installer(str(main_installer))
                results["installer_modified"] = success
                if success:
                    results["installer_backup"] = str(
                        main_installer.with_suffix(".sh.backup-pre-npu")
                    )

            logger.info("NPU integration setup completed successfully")

        except Exception as e:
            logger.error(f"NPU integration setup failed: {e}")
            results["error"] = str(e)

        return results

    def install_npu_bridge_now(self, install_dir: str = None) -> bool:
        """Install NPU bridge immediately"""
        install_dir = install_dir or f"{self.claude_install_dir}/npu"

        try:
            coordinator = NPUBinaryDistributionCoordinator(install_dir=install_dir)

            result = coordinator.run_complete_installation()
            return result.success

        except Exception as e:
            logger.error(f"NPU bridge installation failed: {e}")
            return False

    def generate_integration_report(self) -> Dict[str, Any]:
        """Generate integration status report"""
        claude_dir = Path(self.claude_install_dir)
        npu_dir = claude_dir / "npu"

        report = {
            "claude_dir": str(claude_dir),
            "npu_dir": str(npu_dir),
            "npu_installed": (npu_dir / "bin" / "npu-bridge-server").exists(),
            "wrapper_exists": (claude_dir / "bin" / "claude-npu-installer").exists(),
            "enhanced_wrapper_exists": (
                claude_dir / "bin" / "claude-enhanced"
            ).exists(),
            "installation_report": None,
        }

        # Load NPU installation report if available
        npu_report_file = npu_dir / "installation-report.json"
        if npu_report_file.exists():
            try:
                with open(npu_report_file, "r") as f:
                    report["installation_report"] = json.load(f)
            except (json.JSONDecodeError, IOError):
                pass

        return report


def main():
    """Command-line interface for NPU integration"""
    import argparse

    parser = argparse.ArgumentParser(description="Claude NPU Installer Integration")
    parser.add_argument("--claude-dir", help="Claude installation directory")
    parser.add_argument("--setup", action="store_true", help="Set up NPU integration")
    parser.add_argument(
        "--install-npu", action="store_true", help="Install NPU bridge now"
    )
    parser.add_argument("--status", action="store_true", help="Show integration status")
    parser.add_argument(
        "--report", metavar="FILE", help="Generate integration report to file"
    )

    args = parser.parse_args()

    integrator = ClaudeNPUInstallerIntegration(args.claude_dir)

    if args.setup:
        print("ğŸ”§ Setting up NPU integration...")
        results = integrator.setup_npu_integration()

        if results.get("error"):
            print(f"âŒ Setup failed: {results['error']}")
            sys.exit(1)
        else:
            print("âœ… NPU integration setup completed")

            if results["npu_detected"]:
                print("ğŸ§  Intel NPU detected")

            if results["wrapper_created"]:
                print(f"ğŸ“ NPU installer wrapper: {results.get('wrapper_path')}")

            if results["enhanced_wrapper_created"]:
                print(
                    f"ğŸš€ Enhanced Claude wrapper: {results.get('enhanced_wrapper_path')}"
                )

    elif args.install_npu:
        print("ğŸ“¦ Installing NPU bridge...")
        success = integrator.install_npu_bridge_now()

        if success:
            print("âœ… NPU bridge installed successfully")
        else:
            print("âŒ NPU bridge installation failed")
            sys.exit(1)

    elif args.status:
        report = integrator.generate_integration_report()
        print("ğŸ“Š NPU Integration Status:")
        print(f"   Claude Directory: {report['claude_dir']}")
        print(f"   NPU Installed: {'âœ…' if report['npu_installed'] else 'âŒ'}")
        print(f"   Wrapper Available: {'âœ…' if report['wrapper_exists'] else 'âŒ'}")
        print(
            f"   Enhanced Wrapper: {'âœ…' if report['enhanced_wrapper_exists'] else 'âŒ'}"
        )

    if args.report:
        report = integrator.generate_integration_report()
        with open(args.report, "w") as f:
            json.dump(report, f, indent=2)
        print(f"ğŸ“‹ Integration report saved to: {args.report}")


if __name__ == "__main__":
    main()
