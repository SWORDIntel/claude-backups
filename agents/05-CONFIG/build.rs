//! Build script for Enhanced Vector Router C FFI integration
//! 
//! This build script ensures proper compilation and linking of the Rust
//! vector router library for integration with the C agent communication system.

use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rerun-if-changed=../src/rust/vector_router.rs");
    println!("cargo:rerun-if-changed=../src/c/vector_router.h");
    
    // Set up for C FFI integration
    let target = env::var("TARGET").unwrap();
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    
    // Link against system libraries that the C code expects
    println!("cargo:rustc-link-lib=m");        // Math library
    println!("cargo:rustc-link-lib=pthread");  // POSIX threads
    
    // Intel-specific optimizations for Meteor Lake
    if target.contains("x86_64") {
        println!("cargo:rustc-link-arg=-march=native");
        println!("cargo:rustc-link-arg=-mtune=native");
    }
    
    // Static library output for C integration
    println!("cargo:rustc-crate-type=staticlib");
    println!("cargo:rustc-crate-type=cdylib");
    
    // Tell C build system where to find our library
    println!("cargo:rustc-link-search=native={}", out_dir.display());
    
    // Generate header file path information
    let header_path = PathBuf::from("../src/c/vector_router.h");
    if header_path.exists() {
        println!("cargo:include={}", header_path.canonicalize().unwrap().display());
    }
    
    // Optimization flags for release builds
    if env::var("PROFILE").unwrap() == "release" {
        println!("cargo:rustc-link-arg=-Wl,--gc-sections");  // Remove unused sections
        println!("cargo:rustc-link-arg=-flto=fat");          // Link-time optimization
    }
    
    // Export our FFI functions
    println!("cargo:rustc-cdylib-link-arg=-Wl,--export-dynamic");
    
    // For cbindgen header generation (if installed)
    if let Ok(_) = which::which("cbindgen") {
        let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        let config_path = PathBuf::from(&crate_dir).join("cbindgen.toml");
        
        if config_path.exists() {
            let output_path = PathBuf::from(&crate_dir).join("../src/c/vector_router_generated.h");
            
            let output = std::process::Command::new("cbindgen")
                .args(&["--config", config_path.to_str().unwrap()])
                .args(&["--crate", "vector_router"])
                .args(&["--output", output_path.to_str().unwrap()])
                .current_dir(&crate_dir)
                .output();
                
            match output {
                Ok(result) if result.status.success() => {
                    println!("cargo:warning=Generated C header with cbindgen");
                }
                _ => {
                    println!("cargo:warning=cbindgen failed, using manual header");
                }
            }
        }
    }
    
    // Create build info for debugging
    let build_info = format!(
        "// Generated by build.rs at compile time\n\
         #define VECTOR_ROUTER_BUILD_TARGET \"{}\"\n\
         #define VECTOR_ROUTER_BUILD_PROFILE \"{}\"\n\
         #define VECTOR_ROUTER_BUILD_TIMESTAMP \"{}\"\n",
        target,
        env::var("PROFILE").unwrap(),
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    );
    
    let build_info_path = out_dir.join("build_info.h");
    std::fs::write(&build_info_path, build_info).unwrap();
    
    println!("cargo:include={}", build_info_path.display());
}